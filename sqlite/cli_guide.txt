---- QUERYING ----
CONDITIONS IN SQL: =, != AND <> IN THE SAME
WITH '=' WILL BE DISCRIMINATE UPPER AND LOWER CASE IF USE FOR ALPHABET

---- OPERATION WITH DATABASE ----
.exit OR .quit ---> TO EXIT ENVIRONMENT SQLITE
.tables ---> TO LIST ALL TABLES ARE EXIST
.schema TableName ---> TO SHOW ALL COLUNM EXIST INSIDE TABLE
.headers on ---> TO SET SHOW HEADER
.mode column ---> TO SET COLUNM FORMAT
.timer on

SELECT "TitleOfColumn" FROM "TableName" WHERE NOT "TitleOfColumn" = SetValueToGet;

SELECT "TitleOfColumn" FROM "TableName" WHERE ("TitleOfColumn0" = SetValueToGet0 OR "TitleOfColumn1" = SetValueToGet1) AND "TitleOfColumn" != SetValueToGet;

SELECT * FROM TableName WHERE (age < 18 AND status = 'active') OR (age > 60 AND status = 'retired');

# COMBINE "LIKE" WITH % (ANY CHARACTER) AND _ (MATCH MANY SINGLE CHARACTER) WILl BECOMES POWERFUL & 'LIKE' WILL BE NOT DO NOT DISCRIMINATE UPPER AND LOWER CASE
SELECT "TitleOfColumn" FROM "TableName" WHERE "TitleOfColumn" LIKE '%SetValueToGet%' ---> TO USE ONE %

SELECT "TitleOfColumn" FROM "TableName"
	...> WHERE "TitleOfColumn" LIKE 'SetValueToGet%' ---> TO USE TWO % ---> ISSUE: 'the%' MAYBE there, they, them,....
	OR
	...> WHERE "TitleOfColumn" LIKE 'SetValueToGet %' ---> TO FIX: 'the %'

SELECT "TitleOfColumn" FROM "TableName" WHERE "TitleOfColumn" LIKE 'SetValueToGet%SetNumberToGet%';

SELECT "TitleOfColumn" FROM "TableName" WHERE "TitleOfColumn" LIKE 'P_re'; ---> TO GET Pyre OR Pire OR ... WITH USE ONE _

SELECT "TitleOfColumn" FROM "TableName" WHERE "TitleOfColumn" LIKE 'T___'; ---> TO GET MANY SINGLE CHARACTER WITH MANY _ (IN THIS CASE IS THREE _)

# USE < > >= <= TO QUERYING DATA
SELECT "TitleOfColumn" FROM "TableName"
	...> WHERE "TitleOfColumn0" >= SetNumberToGet0 AND "TitleOfColumn1" <= SetNumberToGet1;
	OR
	...> WHERE "TitleOfColumn" BETWEEN SetNumberToGet0 AND <= SetNumberToGet1; ---> SIMILARLY

# SQL's AGGREGATE FUNCTIONS (COUNT, AVG, MIN, MAX, SUM)
SELECT COUNT(*) FROM "TableName"; ---> GET SUM NUMBER LINE OF TableName INSIDE DATABASE
SELECT COUNT("TitleOfColumn") FROM "TableName"; ---> GET SUM NUMBER LINE OF TitleOfColumn INSIDE TableName OF DATABASE
.
.
.
.
---- RELATING ----
SELECT "TitleOfColumn" FROM "TableName0"
WHERE "TitleOfColumn" = (
	SELECT "TitleOfColumn" FROM "TableName1"
	WHERE "TitleOfColumn" = SetNumberToGet
);

SELECT title FROM books WHERE id IN (
	SELECT book_id FROM authored
	WHERE author_id = (
		SELECT id FROM authors WHERE name = 'Fernanda Melchor'
	);
);

SELECT TitleOfColumn0 FROM TableName0
	...> UNION ---> ????
	...> SELECT TitleOfColumn1 FROM TableName1

SELECT name FROM authors
	...> INTERSECT ---> ????
	...> SELECT name FROM translators;

SELECT name FROM authors
	...> EXCEPT ---> ????
	...> SELECT name FROM translators;

SELECT book_id FROM translated WHERE translator_id = (
	SELECT id FROM translators WHERE name = 'NNN'
)
INTERSECT
SELECT book_id FROM translated WHERE translator_id = (
	SELECT id FROM translators WHERE name = 'VNN'
);

SELECT book_id, ROUND(AVG(rating), 2) AS "average rating"
	...> FROM ratings
	...> GROUP BY book_id
	...> HAVING average rating > SetNumberToGet; ---> ????
.
.
.
.
---- DESIGNING ----
CREATE TABLE "SetNameTable" (
	...> "TitleOfColumn0" SetDataType,
	...> "TitleOfColumn1" SetDataType,
	...> "TitleOfColumn2" SetDataType
	...> );

DROP TABLE "TableNeedToDelete";

ALTER TABLE "NameTableExisting" RENAME TO "SetNewName";

ALTER TABLE "TableNameExisting" ADD COLUMN "SetNameForNewColumn" SetDataType;

ALTER TABLE "TableNameExisting" RENAME COLUMN "TitleOfColumn" TO "RenameForTitleOfColumn";
.
.
.
.
---- WRITING ----
INSERT INTO TableName (TitleOfColumn0, TitleOfColumn1, TitleOfColumn2, ...)
	...> VALUES (value0, value1, value1, ...);

INSERT INTO TableName (TitleOfColumn0, TitleOfColumn1, TitleOfColumn2, ...)
	...> VALUES
	...> (value0, value1, value1, ...),
	...> (value0, value1, value1, ...),
	...> (value0, value1, value1, ...);

.import --csv --skip 1 FileName.csv TableName

.import --csv FileName.csv TempTabble ---> CREATE TABLE WITH NAME IS TempTabble, TITLE & DATA OF CSV FILE WILL BE IMPORT INTO temp TABLE.

INSERT INTO TableName (TitleOfColumn0, TitleOfColumn1, TitleOfColumn2, ...)
	...> SELECT TitleOfColumn0, TitleOfColumn1, TitleOfColumn2, ... FROM TempTabble;

DELETE FROM TableName WHERE Condition;

FOREIGN KEY("artist_id") REFERENCES "artists"("id") ON DELETE **** ---> **** CAN BE IS (RESTRICT, NO ACTION, SET NULL, SET DEFAULTF, CASCADE) | ????

UPDATE created SET artist_id = (
	SELECT id FROM artists
	WHERE name = 'VNN1489'
)
WHERE collection_id = (
	SELECT id FROM collections
	WHERE title = 'Vu Nguyen Nguyen'
);

UPDATE votes SET title = 'VU NGUYEN NGUYEN'
WHERE title LIKE 'VU%'

	????
	CREATE TRIGGER name
	BEFORE INSERT ON table ---> BEFORE or AFTER
or	BEFORE UPDATE OF column ON table
or	BEFORE DELETE ON table
	FOR EACH ROW
	BEGIN
		...;
	END;

????
CREATE TRIGGER sell
...> BEFORE DELETE ON collections
...> FOR EACH ROW
...> BEGIN
...>	INSERT INTO transactions (title, action)
...>	VALUES (OLD.title, sold);
...> END;

????
CREATE TRIGGER buy
...> AFTER INSERT ON collections
...> FOR EACH ROW
...> BEGIN
...>	INSERT INTO transactions (title, action)
...>	VALUES (NEW.title, bought);
...> END;
.
.
.
.
---- VIEWING ----
	SIMPLIFYING
CREATE VIEW longlist AS
...> SELECT name, title FROM authors
...> JOIN authored ON authors.id = authored.author_id
...> JOIN books ON books.id = authored.book_id;

	AGGREGATING
CREATE VIEW average_book_ratings AS
...> SELECT book_id, title, year, ROUND(AVG(rating), 2) AS rating
...> JOIN books ON ratings.book_id = books.id
...> GROUP BY book_id;

	TEMPORARY VIEWS
CREATE TEMPORARY VIEW average_ratings_by_year AS
...> SELECT year, ROUND(AVG(rating), 2) AS rating FROM average_book_ratings
...> GROUP BY year;
SELECT * FROM average_ratings_by_year;
---> IF RUN .quit, TEMPORARY TABLE WILL BE DELETE 

	COMMON TABLE EXPRESSION - CTE
DROP VIEW average_book_ratings;

WITH average_book_ratings AS (
...> SELECT book_id, title, year, ROUND(AVG(rating), 2) AS rating
...> FROM ratings
...> JOIN books ON ratings.book_id = books.id
...> GROUP BY book_id
...> )
...> SELECT year, ROUND(AVG(rating), 2) AS rating
...> FROM average_book_ratings
...> GROUP BY year;

	PARTITIONING
CREATE VIEW 2022 AS
...> SELECT id, title FROM books
...> WHERE year = 2022;
SELECT * FROM 2022;

	SECURING
SELECT id, origin, destination, Anonymous AS rider
...> FROM rides;

CREATE VIEW analysis AS
...> SELECT id, origin, destination, Anonymous AS rider
...> FROM riders;

	TRIGGERS WITH VIEWS
ALTER TABLE collections ADD COLUMN deleted INTEGER DEFAULT 0;

UPDATE collections SET deleted = 1
...> WHERE title = 'your content need to update'; ---> SOFT DELETE

CREATE VIEW current_collections AS
...> SELECT id, title, accession_number, acquired
...> FROM collections WHERE deleted = 0;

CREATE TRIGGER deleted
...> INSTEAD OF DELETE ON current_collections
...> FOR EACH ROW
...> BEGIN
...> 	UPDATE collections SET deleted = 1
...> 	WHERE id = OLD.id;
...> END;

CREATE TRIGGER insert_when_exists
...> INSTEAD OF INSERT ON current_collections
...> FOR EACH ROW
...> WHEN NEW.accession_number IN (
...> 	SELECT accession_number FROM collections
...> )
...> BEGIN
...> 	UPDATE collections SET deleted = 0
...> 	WHERE accession_number = NEW.accession_number;
...> END;
.
.
.
.
---- OPTIMIZING ----
CREATE INDEX SetNameIndex ON TableName (TitleOfColumn0, TitleOfColumn1, ...); ---> AFTER RUN THIS QUERY, THEN RUN QUERY YOU NEED

EXPLAIN QUERY PLAN SELECT * FROM TableName WHWER TitleOfColumn = SetValueToGet; ---> CHECK INDEX HAVE EXISTING

DROP INDEX NameIndex;

	SHOW QUERY PLAN
EXPLAIN QUERY PLAN
...> SELECT title FROM movies WHERE id IN (
...> 	SELECT movie_id FROM start WHERE person_id = (
...>		SELECT id FROM people WHERE name = 'Vu Nguyen Nguyen'
...>	)
...> );

	COVERING INDEXES
CREATE INDEX SetNameIndex ON TableName (TitleOfColumn0, TitleOfColumn1, ...);

	PARTIAL INDEXES
CREATE INDEX SetNameIndex ON TableName (TitleOfColumn0, TitleOfColumn1, ...) WHERE condition;

	VACUUM
VACUUM; ---> CLEANNIG DB

	TRANSACTIONS
BEGIN TRANSACTIONS;
UPDATE accounts SET balance = balance + 10 WHERE id = 2;
COMMIT;

ROLLBACK; ---> ????

	LOCK
BEGIN EXCLUSIVE TRANSACTIONS; ---> LOCK DATABASE